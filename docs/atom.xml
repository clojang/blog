<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:clojang-lfe-io:feed</id><updated>2017-03-16 00:47:34</updated><title type="text">The Clojang Blog</title><link rel="self" href="http://clojang.lfe.io/atom.xml"></link><entry><title>New Clojang Blog</title><updated>2017-03-16 00:47:34</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2017-03/16-004734/new-clojang-blog.html"></link><id>urn:clojang-lfe-io:feed:post:New Clojang Blog</id><content type="html">&lt;p&gt;After a few weeks of hacking and furtive hosting of alpha code and alpha-er content, I think the blog's ready to have more eyeballs on it. It's mostly a vehicle for sharing Clojang project code snippets, clarifying documentation (and then using that to go update the docs!), provide updates on version releases, and maybe even share the occasional experiment. Though it should be fairly low-volume and low-impact, it seemed like a nice way increase the contact area for curious developers who have to (or want to!) straddle the two very different worlds of the JVM (Clojure in particular) and BEAM.&lt;/p&gt;&lt;p&gt;I might not ever have created a dedicated blog for Clojang, but there's been a growing interest among fellow LFErs and BEAMers in general, as well as from curious Clojurians. After the 5th or 6th recent conversation, it was time to do something. One comment in particular, that I should create a &lt;code&gt;STATUS.md&lt;/code&gt; file in the one or more repos really motivated me to do something about a Clojang blog.&lt;/p&gt;&lt;p&gt;For the archivally inclined, the following notes may be of interest. I've been able to reconstruct the older posts from old notes, repositories, and emails, but the furthest back I could find was work I was doing on &lt;a href='https://github.com/Elzor'&gt;Maxim Molchanov&lt;/a&gt;'s &lt;a href='https://github.com/Elzor/erlang-clojure-node'&gt;erlang-clojure-node&lt;/a&gt; repository. There was work done earlier, but I can't find it anywhere, since I don't think any of that got committed. However, it wasn't any time before the end of 2013, so I didn't lose much :-)&lt;/p&gt;&lt;p&gt;There was also some forking I did of &lt;a href='https://github.com/awetzel'&gt;Arnaud Wetzel&lt;/a&gt;'s &lt;a href='https://github.com/awetzel/clojure-erlastic'&gt;clojure-erlastic&lt;/a&gt; repository, but which has since been deleted from Github since that was abandoned and a completely different tack was chosen. I do have an older repo of that on disk somewhere, so if anyone's interested, I can push it up to a Clojang attic ...&lt;/p&gt;&lt;p&gt;Anyway, all this is to say that most of the important stuff has been preserved and the interesting bits are now either in the various &lt;a href='http://github.com/clojang'&gt;Clojang&lt;/a&gt; repos or they've been published on the blog.&lt;/p&gt;</content></entry><entry><title>Clojang Mail List &amp; Slack Channel</title><updated>2017-03-12 21:25:49</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2017-03/12-212549/clojang-mail-list-slack-channel.html"></link><id>urn:clojang-lfe-io:feed:post:Clojang Mail List &amp; Slack Channel</id><content type="html">&lt;h2&gt;Mail List&lt;/h2&gt;&lt;p&gt;A mail list for Clojang has been created and is availble for user subscriptions here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://groups.google.com/forum/#!forum/clojang'&gt;https://groups.google.com/forum/#!forum/clojang&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Once subscribed, you may send emails to the list via clojang@googlegroups.com.&lt;/p&gt;&lt;h2&gt;Slack&lt;/h2&gt;&lt;p&gt;Additionally, a Slack channel has been set up at &lt;a href='http://clojang.slack.com'&gt;clojang.slack.com&lt;/a&gt;. However, you need an invite in order to join the rooms. If you would like to participate in Clojang development or usage discussions, send a direct message to &lt;a href='http://twitter.com/clojang'&gt;@Clojang&lt;/a&gt; (requires mutual follow) or open a &lt;a href='https://github.com/clojang/slack/issues/new'&gt;Slack invitation request ticket&lt;/a&gt;.&lt;/p&gt;</content></entry><entry><title>Clojang is on Twitter</title><updated>2017-03-04 20:19:18</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2017-03/04-201918/clojang-is-on-twitter.html"></link><id>urn:clojang-lfe-io:feed:post:Clojang is on Twitter</id><content type="html">&lt;p&gt;The Clojang project now has a &lt;a href='https://twitter.com/clojang'&gt;Twitter account&lt;/a&gt; :-)&lt;/p&gt;</content></entry><entry><title>Progress Towards the Next Releases</title><updated>2017-03-01 23:52:10</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2017-03/01-235210/progress-towards-the-next-releases.html"></link><id>urn:clojang-lfe-io:feed:post:Progress Towards the Next Releases</id><content type="html">&lt;p&gt;An enormous amount of work has been going on in Clojang-land lately &amp;ndash; enough so that a new release is imminent. The work in jiface and clojang is being driven almost entirely by the long-awaited rewrite of &lt;a href='lfecljapp'&gt;lfecljapp&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The tickets have all been organized into a release, epics, features, tasks, etc., and are linked from this one ticket here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/lfecljapp/issues/20'&gt;isuse #20 - Release 0.4.0&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Clojang, JInterface, &amp; core.async</title><updated>2017-02-24 01:42:24</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2017-02/24-014224/clojang-jinterface-core-async.html"></link><id>urn:clojang-lfe-io:feed:post:Clojang, JInterface, &amp; core.async</id><content type="html">&lt;p&gt;The discussion on Slack the other day kicked off with a question about how messages are consumed in Clojang (and thus jiface and JInterface), and whether, in Clojure code, one could use &lt;code&gt;core.async&lt;/code&gt; to do this.&lt;/p&gt;&lt;p&gt;We'll take a very quick deep (while at the same time superficial) dive into this, but then answer some broader questions to provide a better context for JInterface and the projects built upon it.&lt;/p&gt;&lt;h2&gt;Receiving Messages&lt;/h2&gt;&lt;p&gt;If you are using the &lt;code&gt;clojang&lt;/code&gt; library, receiving messages is as simple as the following (assuming you've followed the best practice of adding the Clojang &lt;code&gt;agent&lt;/code&gt; dependency in your &lt;code&gt;project.clj&lt;/code&gt; file and set the &lt;code&gt;:java-agents&lt;/code&gt; option):&lt;/p&gt;&lt;pre&gt;&lt;code class="cl"&gt;&amp;#40;require '&amp;#91;clojang.core :refer &amp;#91;receive&amp;#93;&amp;#93;

&amp;#40;receive&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At which point, your code blocks until a message is received. When a message comes in, &lt;code&gt;clojang&lt;/code&gt; will automatically convert the Java-OTP hybrid types to Clojure types; when you reply, the conversion will take place in the other direction.&lt;/p&gt;&lt;p&gt;A fuller examples is viewable here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/lfecljapp/blob/master/src/clj/cljnode/server.clj'&gt;https://github.com/clojang/lfecljapp/blob/master/src/clj/cljnode/server.clj&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Under the hood (in the &lt;code&gt;clojang&lt;/code&gt; library), a default OTP node and associated mbox are being used (using the Clojure-idiomatic library &lt;code&gt;jiface&lt;/code&gt;). Under &lt;em&gt;that&lt;/em&gt; hood, Erlang's JInterface Java library is using threads, sockets, and custom queues to handle in-coming and out-going messages.&lt;/p&gt;&lt;p&gt;In other words, not a lot of room for &lt;code&gt;core.async&lt;/code&gt;, unfortunately.&lt;/p&gt;&lt;p&gt;However, there's a &lt;em&gt;little&lt;/em&gt; bit of room :-)&lt;/p&gt;&lt;h2&gt;Command &amp; Convenience Channels&lt;/h2&gt;&lt;p&gt;One way I use &lt;code&gt;core.async&lt;/code&gt; in Clojang applications is to facilitate communications between Clojure functions (i.e., a Clojang server and client, both written in Clojure).&lt;/p&gt;&lt;p&gt;Here's a Clojure server that takes a &lt;code&gt;core.async&lt;/code&gt; channel as an argument:&lt;/p&gt;&lt;pre&gt;&lt;code class="clj"&gt;&amp;#40;defn run
  &amp;#91;cmd-chan&amp;#93;
  &amp;#40;log/info &amp;quot;Starting Clojure node with nodename =&amp;quot;
            &amp;#40;System/getProperty &amp;quot;node.sname&amp;quot;&amp;#41;&amp;#41;
  &amp;#40;let &amp;#91;init-state 0&amp;#93;
    &amp;#40;loop &amp;#91;png-count init-state&amp;#93;
      &amp;#40;match &amp;#40;receive&amp;#41;
        &amp;#91;:register caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/infof &amp;quot;Got :register request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;mbox/link &amp;#40;self&amp;#41; caller&amp;#41;
            &amp;#40;! caller :linked&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;
        &amp;#91;:ping caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/infof &amp;quot;Got :ping request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;! caller :pong&amp;#41;
            &amp;#40;recur &amp;#40;inc png-count&amp;#41;&amp;#41;&amp;#41;
        &amp;#91;:get-ping-count caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/infof &amp;quot;Got :get-ping-count request from %s ...&amp;quot;  caller&amp;#41;
            &amp;#40;! caller png-count&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;
        &amp;#91;:stop caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/warnf &amp;quot;Got :stop request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;! caller :stopping&amp;#41;
            :stopped&amp;#41;
        &amp;#91;:shutdown caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/warnf &amp;quot;Got :shutdown request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;! caller :shutting-down&amp;#41;
            &amp;#40;async/&amp;gt;! cmd-chan :shutdown&amp;#41;&amp;#41;
        &amp;#91;&amp;#95; caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/error &amp;quot;Bad message received: unknown command&amp;quot;&amp;#41;
            &amp;#40;! caller &amp;#91;:error :unknown-command&amp;#93;&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;
        &amp;#91;&amp;#95;&amp;#93;
          &amp;#40;do
            &amp;#40;log/error &amp;quot;Bad message received: improperly formatted&amp;quot;&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this particular case, it doesn't do too much: it simply sends a message back to the calling code when the server has been asked to shutdown. (Note that the &lt;code&gt;:shutdown&lt;/code&gt; clause is sending two types of messages: first an OTP message reply is sent back to the calling OTP node &amp;ndash; which could be either another OTP Clojure node or a BEAM node &amp;ndash; and then a &lt;code&gt;core.async&lt;/code&gt; message is pushed onto the channel that was passed to the server function. In the case where this code was copied from, that channel was started by the function that called &lt;code&gt;&amp;#40;run&amp;#41;&lt;/code&gt;.)&lt;/p&gt;&lt;p&gt;That's a really simple (and not strictly necessary) example of a command channel use case for &lt;code&gt;core.async&lt;/code&gt; in a Clojang app. Here's another case:&lt;/p&gt;&lt;pre&gt;&lt;code class="clj"&gt;&amp;#40;defn otp-bridge
  &amp;quot;This function creates the following in order to facilitate core.async
  communications with the Clojure OTP server:
    1. A dedicated mbox for the OTP bridge &amp;#40;what receives messages from the
       OTP server&amp;#41;
    2. The pid for the dedicated mbox
    3. A core.async channel for sending messages to the OTP server.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;bridge-mbox &amp;#40;mbox/add :otpbrige&amp;#41;
        bridge-pid &amp;#40;mbox/get-pid bridge-mbox&amp;#41;
        bridge-chan &amp;#40;async/chan&amp;#41;&amp;#93;
    &amp;#40;async/go-loop &amp;#91;&amp;#93;
      &amp;#40;when-let &amp;#91;value &amp;#40;async/&amp;lt;! bridge-chan&amp;#41;&amp;#93;
        &amp;#40;! &amp;#91;value bridge-pid&amp;#93;&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;
    {:mbox bridge-mbox
     :pid bridge-pid
     :channel bridge-chan}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As the docstring above says, this function uses &lt;code&gt;core.async&lt;/code&gt; to provide a wrapper for OTP communications with a Clojang server. Interesting and kind of fun, but not really tapping into the power of &lt;code&gt;core.async&lt;/code&gt;.&lt;/p&gt;&lt;h2&gt;Zhang&lt;/h2&gt;&lt;p&gt;There is an experimental project for exploring ways in which Clojure/OTP applications could maximize &lt;code&gt;core.async&lt;/code&gt; while communicating with nodes, services, and full distributed systems in the BEAM world:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='/archives/2016-02/13-121526/zhang.html'&gt;Zhang&lt;/a&gt;  (blog post/project announcement)&lt;/li&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/zhang'&gt;zhang on github&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Those two links provide some good introductory material, so I won't duplicate that here. Note, however, than while the &lt;code&gt;jiface&lt;/code&gt; and &lt;code&gt;clojang&lt;/code&gt; libs are stabilizing, little effort is being applied to &lt;code&gt;zhang&lt;/code&gt;. As such, there's not much to the project currently.&lt;/p&gt;</content></entry><entry><title>clojang &amp; agent v0.3.0 Released</title><updated>2017-01-17 19:48:58</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2017-01/17-194858/clojang-agent-v0-3-0-released.html"></link><id>urn:clojang-lfe-io:feed:post:clojang &amp; agent v0.3.0 Released</id><content type="html">&lt;p&gt;The new releases are available here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/clojang/releases/tag/0.3.0'&gt;clojang&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/agent/releases/tag/0.3.0'&gt;agent&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Enjoy!&lt;/p&gt;</content></entry><entry><title>jiface &amp; clojang-agent v0.1.0 Released</title><updated>2016-04-30 21:43:38</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2016-04/30-214338/jiface-clojang-agent-v0-1-0-released.html"></link><id>urn:clojang-lfe-io:feed:post:jiface &amp; clojang-agent v0.1.0 Released</id><content type="html">&lt;p&gt;The new releases are available here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/jiface/releases/tag/0.1.0'&gt;jiface&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/agent/releases/tag/0.1.0'&gt;agent&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Enjoy!&lt;/p&gt;</content></entry><entry><title>clojang v0.1.0 Released</title><updated>2016-02-15 02:04:57</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2016-02/15-020457/clojang-v0-1-0-released.html"></link><id>urn:clojang-lfe-io:feed:post:clojang v0.1.0 Released</id><content type="html">&lt;p&gt;After two months of intense development, the first (alpha) release of clojang is out!&lt;/p&gt;&lt;p&gt;Available &lt;a href='https://github.com/clojang/clojang/releases/tag/0.1.0'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Enjoy!&lt;/p&gt;</content></entry><entry><title>Zhang</title><updated>2016-02-13 12:15:26</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2016-02/13-121526/zhang.html"></link><id>urn:clojang-lfe-io:feed:post:Zhang</id><content type="html">&lt;p&gt;Today &lt;a href='http://github.com/clojang'&gt;yet another Clojang project&lt;/a&gt; was created:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/zhang'&gt;zhang&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;From the project's README, here is a (partial) list of desired features:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the ability to quickly create and destroy processes, nodes, and mboxes&lt;/li&gt;&lt;li&gt;ensure the safe "crashing" of a process&lt;/li&gt;&lt;li&gt;very fast message-passing between processes&lt;/li&gt;&lt;li&gt;the ability support very large numbers of processes&lt;/li&gt;&lt;li&gt;shared nothing&lt;/li&gt;&lt;li&gt;low-overhead function-level mailboxes&lt;/li&gt;&lt;li&gt;ordered message queues&lt;/li&gt;&lt;li&gt;timeouts&lt;/li&gt;&lt;li&gt;pattern matching (&lt;code&gt;core.match&lt;/code&gt;) and selective &lt;code&gt;receive&lt;/code&gt;&lt;/li&gt;&lt;li&gt;process registration hooks (in order to support arbitrary publishing mechanisms)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A great deal of work (and time in production deployments) has gone into Erlang's JInterface Java package. Using it in Clojure has been such a pain, however, that two projects were created to mitigate two major issues around that (Clojure idioms and sane OTP defaults). Even with these libraries under active development, their ultimate goals (and areas of focus) are beyond the scope of addressing the JInterface internals of threads, sockets, and queues. As such, zhang was created to find a good solution for replacing those bits with &lt;code&gt;core.async&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The project is experimental in nature and will likely be developed only very slowly, especially while &lt;a href='https://github.com/clojang/jiface'&gt;jiface&lt;/a&gt; and &lt;a href='https://github.com/clojang/clojang'&gt;clojang&lt;/a&gt; are in development. Once those projects hit a level of stability, though, I expect to be spending more time on the interesting problems to be solved in zhang.&lt;/p&gt;&lt;p&gt;Additionally, I expect that zhang, jiface, and clojang will end up sharing a certain amount of code. Only once jiface and clojang stabilize will it become clear what common bits for zhang can be split out into supporting library projects. I expect that one of these will be the type conversions developed in clojang (i.e., there will likely eventually be a clojang/types library and corresponding repo).&lt;/p&gt;&lt;p&gt;Since zhang aims to be messaging and deployment agnostic, there could also be a set of message implementation libraries created &amp;ndash; the first of which would be the default: OTP process messaging. However, there's no reason other message formats couldn't be implemented or integrated. This would allow zhang (and thus Clojang in general) to transcend the current domain of OTP messaging and take fault-tolerant, soft real-time programming into other areas of the Clojure ecosystem.&lt;/p&gt;&lt;p&gt;On a fun side note, the zhang project takes it's name from &lt;a href='https://en.wikipedia.org/wiki/Zhang_Heng'&gt;Zhang Heng&lt;/a&gt;, who approximated pi early in the first millennium (Han Dynasty). This is an obscure pun, since the Erlang process model could be, in some ways, interpreted as an approximation of the &lt;a href='https://en.wikipedia.org/wiki/%CE%A0-calculus'&gt;process calculus&lt;/a&gt;. In addition to being a mathematician, Zhang Heng was also a poet, astronomer, and engineer &amp;ndash; a wonderful patron for a software project :-)&lt;/p&gt;</content></entry><entry><title>Announcing jiface, clojang, &amp; a Clojure OTP agent</title><updated>2016-01-19 18:42:24</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2016-01/19-184224/announcing-jiface-clojang-a-clojure-otp-agent.html"></link><id>urn:clojang-lfe-io:feed:post:Announcing jiface, clojang, &amp; a Clojure OTP agent</id><content type="html">&lt;p&gt;After all the hacking on the Clojure/LFE/Erlang code &amp;ndash; a prototype version of Clojang &amp;ndash; it has become clear that Clojang really needs to be split into projects with separate concerns. Firstly, there needs to be a dedicated project for two very distinct aspects of this mini-ecosystem:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There should be a low-level Clojure wrapper around JInterface (having to  write   OTP-interop code using Clojure's Java interop makes for unbelievably  ugly code ...). This library should have no opinions about anything, instead  simply providing a minimally Clojure-idiomatic wrapper around JInterface.&lt;/li&gt;&lt;li&gt;In addition, there needs to be a mid-level API that wrapps jiface and allows  one to use even more idiomatic Clojure (and perhaps some LFE-isms, too). This  library can have the luxury of being opinionated about how things should be  done, including default nodes, mboxes, etc., as well as automatic conversion  of Erlang/OTP types.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Finally, there is a bit of functionality that can be broken out into another project, usable by clojang and other higher-level libs that would benefit from some basic OTP conveniences: a &lt;a href='http://github.com/clojang/agent'&gt;Clojure/Java agent&lt;/a&gt; that helps set up a default OTP node in Clojure applications.&lt;/p&gt;&lt;p&gt;The home for these projects is here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://github.com/clojang'&gt;githb.com/clojang&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Or, individually:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/jiface'&gt;githb.com/clojang/jiface&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/clojang'&gt;githb.com/clojang/clojang&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/agent'&gt;githb.com/clojang/agent&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The work started last year on &lt;a href='https://github.com/awetzel/clojure-erlastic'&gt;a fork of Arnaud Wetzel'a code&lt;/a&gt;, while interesting at first, doesn't really provide a general and open-ended solution that's needed for larger-scale applications. As such, the new version of clojang &amp;ndash; as well as its other new sister projects &amp;ndash; represents a completely fresh start with no shared code history. This should leave things maximally flexible.&lt;/p&gt;</content></entry><entry><title>lfecljapp v0.3.0 Release</title><updated>2015-09-19 20:20:40</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2015-09/19-202040/lfecljapp-v0-3-0-release.html"></link><id>urn:clojang-lfe-io:feed:post:lfecljapp v0.3.0 Release</id><content type="html">&lt;p&gt;The project that kicked this whole thing off just got a series of updates. In fact, it got enough of them to warrant a new release. However, this will likely be the last significant update for a while, since I'm going to spend any time I have for this work on core libraries of jiface and clojang.&lt;/p&gt;&lt;p&gt;Hopefully, the next release of lfecljapp will be using released versions of jiface, clojang, and the agent.&lt;/p&gt;&lt;p&gt;Stay tuned ...&lt;/p&gt;</content></entry><entry><title>Clojang</title><updated>2015-09-13 23:19:09</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2015-09/13-231909/clojang.html"></link><id>urn:clojang-lfe-io:feed:post:Clojang</id><content type="html">&lt;p&gt;After the initial work with Erlang, LFE, Clojure, and JInterface last year, I've been pursuing other options of simplifying BEAM development (LFE in particular) in conjunction with JVM apps (Clojure, really). I recently came across the work of &lt;a href='https://github.com/awetzel'&gt;Arnaud Wetzel&lt;/a&gt; in his &lt;a href='https://github.com/awetzel/clojure-erlastic'&gt;clojure-erlastic&lt;/a&gt; project.&lt;/p&gt;&lt;p&gt;This looks promising enough to fork and experiment with, so I've done just that. However, since I plan on doing much more than what clojure-erlastic provides, I've changed the name of the forked repo to "clojang" :-)&lt;/p&gt;</content></entry><entry><title>A New Project</title><updated>2014-05-11 22:55:55</updated><author><name>oubiwann</name></author><link href="http://clojang.lfe.io//archives2014-05/11-225555/a-new-project.html"></link><id>urn:clojang-lfe-io:feed:post:A New Project</id><content type="html">&lt;p&gt;I've been hacking on LFE/Clojure code lately, based on the work that &lt;a href='https://github.com/Elzor'&gt;Maxim Molchanov&lt;/a&gt; has done in his &lt;a href='https://github.com/Elzor/erlang-clojure-node'&gt;Erlang/Clojure repo&lt;/a&gt;. This could end up being a great deal of fun :-)&lt;/p&gt;&lt;p&gt;Here's a quick sample of his Erlang supervisor for a Clojure node:&lt;/p&gt;&lt;pre&gt;&lt;code class="erlang"&gt;-module&amp;#40;clojurenode&amp;#95;sup&amp;#41;.

-behaviour&amp;#40;supervisor&amp;#41;.

%% API
-export&amp;#40;&amp;#91;start&amp;#95;link/0&amp;#93;&amp;#41;.

%% Supervisor callbacks
-export&amp;#40;&amp;#91;init/1&amp;#93;&amp;#41;.

%% Helper macro for declaring children of supervisor
-define&amp;#40;CHILD&amp;#40;I, Type&amp;#41;, {I, {I, start&amp;#95;link, &amp;#91;&amp;#93;}, permanent, 5000, Type, &amp;#91;I&amp;#93;}&amp;#41;.

%% ===================================================================
%% API functions
%% ===================================================================

start&amp;#95;link&amp;#40;&amp;#41; -&amp;gt;
    supervisor:start&amp;#95;link&amp;#40;{local, ?MODULE}, ?MODULE, &amp;#91;&amp;#93;&amp;#41;.

%% ===================================================================
%% Supervisor callbacks
%% ===================================================================

init&amp;#40;&amp;#91;&amp;#93;&amp;#41; -&amp;gt;
    {ok, { {one&amp;#95;for&amp;#95;one, 5, 10}, &amp;#91;?CHILD&amp;#40;clj&amp;#95;controller, worker&amp;#41;&amp;#93;} }.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note sure if the work I'm doing with LFE and Clojure will go anywhere yet, but even if it doesn't, it's a ton of fun :-)&lt;/p&gt;</content></entry></feed>